/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

// #include "Riostream.h" 

#include "RooDoubleCB.h" 
// #include "RooAbsReal.h" 
// #include "RooAbsCategory.h" 
// #include <math.h> 


ClassImp(RooDoubleCB) 

 RooDoubleCB::RooDoubleCB(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _mean,
                        RooAbsReal& _sigma,
                        RooAbsReal& _alpha,
                        RooAbsReal& _n) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   mean("mean","mean",this,_mean),
   sigma("sigma","sigma",this,_sigma),
   alpha("alpha","alpha",this,_alpha),
   n("n","n",this,_n)
 { 
 } 


 RooDoubleCB::RooDoubleCB(const RooDoubleCB& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   mean("mean",this,other.mean),
   sigma("sigma",this,other.sigma),
   alpha("alpha",this,other.alpha),
   n("n",this,other.n)
 { 
 } 



 Double_t RooDoubleCB::evaluate() const 
 { 
   

/*
   // // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   // return 1.0 ; 
   float A, B;
   float thrs = (x - mean) / sigma;
   // float thr = TMath::Abs(thrs);
   // gaussian core
   if (thrs < alpha)
   {
      float res = TMath::Exp(0.5*thrs*thrs);
      return res;
   } 
   else if (thrs > -1.*alpha)
   {
      float res = TMath::Exp(-0.5*thrs*thrs);
      return res;
   }
   // power tail
   else
   {
      A = TMath::Power( (n / TMath::Abs(alpha)) , n) * TMath::Exp(-0.5*alpha*alpha);
      B = (n / TMath::Abs(alpha) ) - TMath::Abs(alpha);
      float res = A*TMath::Power((B - thrs), -1.*n);
      return res;
   }
   */
   // double xA [1] = {x};
   // double parsifal[4] = {alpha, n, mean, sigma};
   // double res = TheCrystalBall(xA, parsifal);
   // return res;
   double A, B;
   double N = 1.0; // no norm
   if (alpha < 0)
   {
      A = pow((n/(-1*alpha)),n)*TMath::Exp((-1.)*alpha*alpha/2.); 
      B = n/(-1.*alpha) + alpha; 
   }
   else
   {
      A = pow((n/alpha),n)*TMath::Exp((-1.)*alpha*alpha/2.); 
      B = n/alpha - alpha;
   }
   double f; 
   if (TMath::Abs((x-mean)/sigma) < TMath::Abs(alpha) ) 
    f = N*TMath::Exp((-1.)*(x-mean)*(x-mean)/(2.*sigma*sigma)); 
   else if (((x-mean)/sigma) < (-1.)*alpha )
    f = N*A*pow((B- (x-mean)/sigma),(-1.*n)); // left tail
   else
    f = N*A*pow( (B- ((mean-x)/sigma)),(-1.*n)); // right tail

   return f;
 } 



// double RooDoubleCB::TheCrystalBall
// (double* Ax, double* Apar){ 
//   //http://en.wikipedia.org/wiki/Crystal_Ball_function 
//   double xcur = Ax[0]; 
//   double Aalpha = Apar[0]; 
//   double An = Apar[1]; 
//   double Amu = Apar[2]; 
//   double Asigma = Apar[3]; 
//   // double N = par[4]; 
//   double N = 1.0; // no normalization
//   // TF1* exp = new TF1("exp","exp(x)",1e-20,1e20); 
//   double A; double B; 
//   if (Aalpha < 0){ 
//     A = pow((n/(-1*Aalpha)),An)*TMath::Exp((-1)*Aalpha*Aalpha/2); 
//     B = An/(-1*Aalpha) + Aalpha;} 
//   else { 
//     A = pow((An/Aalpha),An)*TMath::Exp((-1)*Aalpha*Aalpha/2); 
//     B = An/Aalpha - Aalpha;} 
//     double f; 
//   if (TMath::Abs((xcur-Amu)/Asigma) < TMath::Abs(Aalpha) ) 
//     f = N*TMath::Exp((-1)*(xcur-Amu)*(xcur-Amu)/(2*Asigma*Asigma)); 
//   else if (((xcur-Amu)/Asigma) < (-1.)*Aalpha )
//     f = N*A*pow((B- (xcur-Amu)/Asigma),(-1*An)); // left tail
//   else
//     f = N*A*pow( (B- (Amu-xcur)/Asigma),(-1*An)); // right tail
//   // delete exp; 
//   return f; 
// } 


